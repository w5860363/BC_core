diff --git a/sql/anticheat/world_anticheat.sql b/sql/anticheat/world_anticheat.sql
new file mode 100644
index 0000000..cf209a9
--- /dev/null
+++ b/sql/anticheat/world_anticheat.sql
@@ -0,0 +1,3 @@
+-- BlizzLikeCore Anticheat
+DELETE FROM `blizzlike_string` WHERE `entry` = 6620;
+INSERT INTO `blizzlike_string` VALUES (6620,'|cfff00000Movement Anticheat: %s was %s using: %s.|r',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
\ No newline at end of file
diff --git a/src/game/Language.h b/src/game/Language.h
index 01f45ef..c68a338 100644
--- a/src/game/Language.h
+++ b/src/game/Language.h
@@ -835,6 +835,7 @@ enum BlizzLikeStrings
     LANG_GM_ANNOUNCE_COLOR               = 6615,
 
     LANG_GM_SILENCE                      = 6616,              // GM Silenced Spell 1852
+    LANG_GM_AC_ANNOUNCE                  = 6620,              // GM Movement Anticheat Announce
 
     // Use for not-in-offcial-sources patches
     //                                    10000-10999
diff --git a/src/game/MovementHandler.cpp b/src/game/MovementHandler.cpp
index 93a6251..601f6f2 100644
--- a/src/game/MovementHandler.cpp
+++ b/src/game/MovementHandler.cpp
@@ -8,6 +8,7 @@
 #include "WorldSession.h"
 #include "Opcodes.h"
 #include "Log.h"
+#include "World.h"
 #include "Corpse.h"
 #include "Player.h"
 #include "MapManager.h"
@@ -15,6 +16,8 @@
 #include "BattleGround.h"
 #include "WaypointMovementGenerator.h"
 #include "InstanceSaveMgr.h"
+#include "AccountMgr.h"
+#include "Language.h"
 
 void WorldSession::HandleMoveWorldportAckOpcode(WorldPacket & /*recv_data*/)
 {
@@ -43,6 +46,12 @@ void WorldSession::HandleMoveWorldportAckOpcode()
         return;
     }
 
+    // Movement Anticheat
+    GetPlayer()->m_anti_plskipanticheat = true;
+
+    if (World::GetMvAnticheatDebug())
+        sLog.outBasic("Movement Anticheat: player %s HandleMoveWorldportAckOpcode", GetPlayer()->GetName());
+
     // get the destination map entry, not the current one, this will fix homebind and reset greeting
     MapEntry const* mEntry = sMapStore.LookupEntry(loc.GetMapId());
     InstanceTemplate const* mInstance = objmgr.GetInstanceTemplate(loc.GetMapId());
@@ -189,6 +198,12 @@ void WorldSession::HandleMoveTeleportAck(WorldPacket& recv_data)
     if (guid != plMover->GetGUID())
         return;
 
+    // Movement Anticheat
+    GetPlayer()->m_anti_plskipanticheat = true;
+
+    if (World::GetMvAnticheatDebug())
+        sLog.outBasic("Movement Anticheat: player %s HandleMoveTeleportAck", GetPlayer()->GetName());
+
     plMover->SetSemaphoreTeleportNear(false);
 
     uint32 old_zone = plMover->GetZoneId();
@@ -225,6 +240,8 @@ void WorldSession::HandleMoveTeleportAck(WorldPacket& recv_data)
 
 void WorldSession::HandleMovementOpcodes(WorldPacket& recv_data)
 {
+    uint32 timediff = getMSTime();
+
     Unit* mover = _player->m_mover;
 
     ASSERT(mover != NULL);                                  // there must always be a mover
@@ -234,7 +251,12 @@ void WorldSession::HandleMovementOpcodes(WorldPacket& recv_data)
     // ignore, waiting processing in WorldSession::HandleMoveWorldportAckOpcode and WorldSession::HandleMoveTeleportAck
     if (plMover && plMover->IsBeingTeleported())
     {
+        GetPlayer()->m_anti_plskipanticheat = true;
         recv_data.rpos(recv_data.wpos());                   // prevent warnings spam
+
+        if (World::GetMvAnticheatDebug())
+            sLog.outBasic("Movement Anticheat: player %s IsBeingTeleported", GetPlayer()->GetName());
+
         return;
     }
 
@@ -264,73 +286,446 @@ void WorldSession::HandleMovementOpcodes(WorldPacket& recv_data)
     {
         // transports size limited
         // (also received at zeppelin/lift leave by some reason with t_* as absolute in continent coordinates, can be safely skipped)
-        if (movementInfo.GetTransportPos()->GetPositionX() > 50 || movementInfo.GetTransportPos()->GetPositionY() > 50 || movementInfo.GetTransportPos()->GetPositionZ() > 50)
+        if (movementInfo.GetTransportPos()->GetPositionX() > 60 || movementInfo.GetTransportPos()->GetPositionY() > 60 || movementInfo.GetTransportPos()->GetPositionZ() > 60)
             return;
 
         if (!BlizzLike::IsValidMapCoord(movementInfo.GetPos()->GetPositionX() + movementInfo.GetTransportPos()->GetPositionX(), movementInfo.GetPos()->GetPositionY() + movementInfo.GetTransportPos()->GetPositionY(),
             movementInfo.GetPos()->GetPositionZ() + movementInfo.GetTransportPos()->GetPositionZ(), movementInfo.GetPos()->GetOrientation() + movementInfo.GetTransportPos()->GetOrientation()))
             return;
 
-        // if we boarded a transport, add us to it
-        if (plMover && !plMover->m_transport)
+        if (plMover && plMover->m_anti_transportGUID == 0 && movementInfo.t_guid != 0)
         {
-            // elevators also cause the client to send MOVEFLAG_ONTRANSPORT - just unmount if the guid can be found in the transport list
-            for (MapManager::TransportSet::iterator iter = MapManager::Instance().m_Transports.begin(); iter != MapManager::Instance().m_Transports.end(); ++iter)
+            // if we boarded a transport, add us to it
+            if (!plMover->m_transport)
             {
-                if ((*iter)->GetGUID() == movementInfo.t_guid)
+                float trans_rad = movementInfo.GetTransportPos()->GetPositionX()*movementInfo.GetTransportPos()->GetPositionX() + movementInfo.GetTransportPos()->GetPositionY()*movementInfo.GetTransportPos()->GetPositionY() + movementInfo.GetTransportPos()->GetPositionZ()*movementInfo.GetTransportPos()->GetPositionZ();
+                if (trans_rad > 3600.0f) // transport radius = 60 yards //cheater with on_transport_flag
                 {
-                    // unmount before boarding
-                    plMover->RemoveSpellsCausingAura(SPELL_AURA_MOUNTED);
-
-                    plMover->m_transport = (*iter);
-                    (*iter)->AddPassenger(plMover);
-                    break;
+                    return;
+                }
+                // elevators also cause the client to send MOVEFLAG_ONTRANSPORT - just unmount if the guid can be found in the transport list
+                for (MapManager::TransportSet::iterator iter = MapManager::Instance().m_Transports.begin(); iter != MapManager::Instance().m_Transports.end(); ++iter)
+                {
+                    if ((*iter)->GetGUID() == movementInfo.t_guid)
+                    {
+                        // unmount before boarding
+                        plMover->RemoveSpellsCausingAura(SPELL_AURA_MOUNTED);
+
+                        plMover->m_transport = (*iter);
+                        (*iter)->AddPassenger(plMover);
+                        break;
+                    }
                 }
             }
+
+            GameObject* obj = HashMapHolder<GameObject>::Find(movementInfo.t_guid);
+            if (obj)
+                plMover->m_anti_transportGUID = obj->GetDBTableGUIDLow();
+            else
+                plMover->m_anti_transportGUID = GUID_LOPART(movementInfo.t_guid);
+
+            if (World::GetMvAnticheatDebug())
+                sLog.outBasic("Movement Anticheat: player %s on transport %d", plMover->GetName(), plMover->m_anti_transportGUID ? plMover->m_anti_transportGUID : 0);
         }
     }
     else if (plMover && plMover->m_transport)               // if we were on a transport, leave
     {
+        if (World::GetMvAnticheatDebug())
+            sLog.outBasic("Movement Anticheat: player %s left the transport %d", plMover->GetName(), plMover->m_anti_transportGUID ? plMover->m_anti_transportGUID : 0);
+
         plMover->m_transport->RemovePassenger(plMover);
         plMover->m_transport = NULL;
+        plMover->m_anti_transportGUID = 0;
         movementInfo.ClearTransportData();
     }
+    else if (plMover && plMover->m_anti_transportGUID != 0)
+    {
+        if (World::GetMvAnticheatDebug())
+            sLog.outBasic("Movement Anticheat: player %s no more transport %d", plMover->GetName(), plMover->m_anti_transportGUID ? plMover->m_anti_transportGUID : 0);
 
-    // fall damage generation (ignore in flight case that can be triggered also at lags in moment teleportation to another map).
-    if (opcode == MSG_MOVE_FALL_LAND && plMover && !plMover->isInFlight())
-        plMover->HandleFallDamage(movementInfo);
+        plMover->m_anti_transportGUID = 0;
+    }
 
-    if (plMover && (movementInfo.HasMovementFlag(MOVEFLAG_SWIMMING) != plMover->IsInWater()))
+    if (plMover)
     {
-        // now client not include swimming flag in case jumping under water
-        plMover->SetInWater(!plMover->IsInWater() || plMover->GetBaseMap()->IsUnderWater(movementInfo.GetPos()->GetPositionX(), movementInfo.GetPos()->GetPositionY(), movementInfo.GetPos()->GetPositionZ()));
-    }
+        // Movement Anticheat		 
+        bool updateorientationonly = false;
+        bool acpassed = true;
 
-    /* process position-change */
-    recv_data.put<uint32>(5, getMSTime());                  // offset flags(4) + unk(1)
-    WorldPacket data(opcode, mover->GetPackGUID().size() + recv_data.size());
-    data << mover->GetPackGUID();
-    data.append(recv_data.contents(), recv_data.size());
-    if (mover->isCharmed() && mover->GetCharmer())
-        mover->GetCharmer()->SendMessageToSet(&data, false);
-    else
-        mover->SendMessageToSet(&data, false);
+        if (!World::GetEnableMvAnticheat() || GetPlayer()->GetSession()->GetSecurity() > World::GetMvAnticheatGmLevel())
+            plMover->m_anti_plskipanticheat = true;
 
-    mover->m_movementInfo = movementInfo;
-    mover->SetPosition(movementInfo.GetPos()->GetPositionX(), movementInfo.GetPos()->GetPositionY(), movementInfo.GetPos()->GetPositionZ(), movementInfo.GetPos()->GetOrientation());
+        if (!movementInfo.HasMovementFlag(MOVEFLAG_MOVING) && !mover->HasUnitMovementFlag(MOVEFLAG_MOVING) && !(opcode == MSG_MOVE_FALL_LAND))
+        {
+            if (World::GetMvAnticheatDebug())
+                sLog.outDebug("Movement Anticheat: player %s update orientation only", plMover->GetName());
 
-    if (plMover)                                            // nothing is charmed, or player charmed
-    {
-        if (opcode == MSG_MOVE_FALL_LAND || plMover->m_lastFallTime > movementInfo.GetFallTime() || plMover->m_lastFallZ < movementInfo.GetPos()->GetPositionZ())
-            plMover->SetFallInformation(movementInfo.GetFallTime(), movementInfo.GetPos()->GetPositionZ());
+            plMover->m_anti_plskipanticheat = true;
+            updateorientationonly = true;
+        }
+
+        // Fall Damage Generation (ignore in flight case that can be triggered also at lags in moment teleportation to another map).
+        if (opcode == MSG_MOVE_FALL_LAND && !plMover->isInFlight())
+        {
+            if (!plMover->m_anti_ontaxipath && !plMover->m_anti_flymounted)
+                plMover->HandleFallDamage(movementInfo);
+
+            plMover->m_anti_ontaxipath = false;
+            plMover->m_anti_justjumped = 0;
+            plMover->m_anti_jumpbase = 0;
+            plMover->m_anti_isjumping = false;
+        }
+        else if (opcode == MSG_MOVE_START_SWIM)
+            plMover->m_anti_isjumping = false;
+        else if (opcode == MSG_MOVE_JUMP)
+            plMover->m_anti_isjumping = true;
 
-        // we should add the check only for class hunter
-        if (plMover->isMovingOrTurning())
-            plMover->RemoveSpellsCausingAura(SPELL_AURA_FEIGN_DEATH);
+        if (movementInfo.HasMovementFlag(MOVEFLAG_SWIMMING) != plMover->IsInWater())
+        {
+            // Now client not include swimming flag in case jumping under water
+            plMover->SetInWater(!plMover->IsInWater() || plMover->GetBaseMap()->IsUnderWater(movementInfo.GetPos()->GetPositionX(), movementInfo.GetPos()->GetPositionY(), movementInfo.GetPos()->GetPositionZ()));
+            plMover->m_anti_justjumped = 0;
+        }
+        /*----------------------*/
+
+        if (World::GetMvAnticheatDebug())
+        {
+            sLog.outDebug("Movement Anticheat: player %s newcoord: tm:%d ftm:%d | %f, %f, %fo(%f) [%X][%s]| transport: %f, %f, %fo(%f)", plMover->GetName(), movementInfo.time, movementInfo.GetFallTime(), movementInfo.GetPos()->GetPositionX(), movementInfo.GetPos()->GetPositionY(), movementInfo.GetPos()->GetPositionZ(), movementInfo.GetPos()->GetOrientation(), movementInfo.GetMovementFlags(), LookupOpcodeName(opcode), movementInfo.GetTransportPos()->GetPositionX(), movementInfo.GetTransportPos()->GetPositionY(), movementInfo.GetTransportPos()->GetPositionZ(), movementInfo.GetTransportPos()->GetOrientation());
+            sLog.outDebug("Transport: %d |  tguid: %d - %d", plMover->m_anti_transportGUID, GUID_LOPART(movementInfo.t_guid), GUID_HIPART(movementInfo.t_guid));
+        }
+
+        // Anti-Passiv-Movement-Hack
+        if (!plMover->IsInWater() && updateorientationonly && plMover->m_anti_transportGUID == 0 && !plMover->m_anti_plskipanticheat)
+        {
+            if ((abs(plMover->GetPositionX() - movementInfo.GetPos()->GetPositionX()) > 0.1f) ||
+                (abs(plMover->GetPositionY() - movementInfo.GetPos()->GetPositionY()) > 0.1f) ||
+                (abs(plMover->GetPositionZ() - movementInfo.GetPos()->GetPositionZ()) > 0.1f))
+            {
+                if (World::GetMvAnticheatDebug())
+                {
+                    sLog.outError("Movement Anticheat: player %s has Passiv-Movement-Hack alarm. dx=%f, dy=%f, dz=%f",
+                        plMover->GetName(),
+                        abs(plMover->GetPositionX() - movementInfo.GetPos()->GetPositionX()),
+                        abs(plMover->GetPositionY() - movementInfo.GetPos()->GetPositionY()),
+                        abs(plMover->GetPositionZ() - movementInfo.GetPos()->GetPositionZ()));
+                }
+                plMover->m_anti_lastcheat = "Passiv Movement Hack";
+                acpassed = false;
+            }
+        }
+
+        //uint32 curDest = plMover->m_taxi.GetTaxiDestination(); // check taxi flight
+        //if ((plMover->m_anti_transportGUID == 0) && !curDest)
+        if ((plMover->m_anti_transportGUID == 0) && !plMover->m_anti_ontaxipath && !plMover->m_anti_plskipanticheat)
+        {
+            UnitMoveType move_type;
+
+            if (movementInfo.HasMovementFlag(MOVEFLAG_FLYING))
+                move_type = movementInfo.HasMovementFlag(MOVEFLAG_BACKWARD) ? MOVE_FLIGHT_BACK : MOVE_FLIGHT;
+            else if (movementInfo.HasMovementFlag(MOVEFLAG_SWIMMING))
+                move_type = movementInfo.HasMovementFlag(MOVEFLAG_BACKWARD) ? MOVE_SWIM_BACK : MOVE_SWIM;
+            else if (movementInfo.HasMovementFlag(MOVEFLAG_WALK_MODE))
+                move_type = MOVE_WALK;
+            else    //hmm... in first time after login player has MOVE_SWIMBACK instead MOVE_WALKBACK
+                move_type = movementInfo.HasMovementFlag(MOVEFLAG_BACKWARD) ? MOVE_SWIM_BACK : MOVE_RUN;
+
+            float allowed_delta = 0;
+            float current_speed = plMover->GetSpeed(move_type);
+
+            float delta_x = plMover->GetPositionX() - movementInfo.GetPos()->GetPositionX();
+            float delta_y = plMover->GetPositionY() - movementInfo.GetPos()->GetPositionY();
+            float delta_z = plMover->GetPositionZ() - movementInfo.GetPos()->GetPositionZ();
+            float real_delta = delta_x * delta_x + delta_y * delta_y;
+
+            float time_delta = movementInfo.time - plMover->m_anti_lastmovetime;
+            if (time_delta > 0)
+                plMover->m_anti_lastmovetime = movementInfo.time;
+            else
+                time_delta = 0;
+
+            time_delta = (time_delta < 1500) ? time_delta / 1000 : 1.5f; // normalize time - 1.5 second allowed for heavy loaded server
+
+            float tg_z = -99999; // tangens
+            if (!(movementInfo.GetMovementFlags() & (MOVEFLAG_FLYING | MOVEFLAG_SWIMMING)))
+                tg_z = (real_delta != 0) ? (delta_z * delta_z / real_delta) : tg_z;
+
+            if (current_speed < plMover->m_anti_last_hspeed)
+            {
+                allowed_delta = plMover->m_anti_last_hspeed;
+                if (plMover->m_anti_lastspeed_changetime == 0)
+                    plMover->m_anti_lastspeed_changetime = movementInfo.time + (uint32)floor(((plMover->m_anti_last_hspeed / current_speed) * 1000)) + 100; //100ms above for random fluctuating =)))
+            }
+            else
+                allowed_delta = current_speed;
+
+            allowed_delta = allowed_delta * time_delta;
+            allowed_delta = allowed_delta * allowed_delta + 2;
+
+            // Anti-Gravitation-Hack
+            float JumpHeight = ((plMover->m_anti_jumpbase > 0) ? plMover->m_anti_jumpbase : 0) - movementInfo.GetPos()->GetPositionZ();
+            if ((plMover->m_anti_jumpbase != 0)
+                && (plMover->m_anti_justjumped > 0)
+                && !(movementInfo.HasMovementFlag(MOVEFLAG_SWIMMING) || movementInfo.HasMovementFlag(MOVEFLAG_FLYING)
+                    || movementInfo.HasMovementFlag(MOVEFLAG_FLYING2))
+                && (JumpHeight < GetPlayer()->m_anti_last_vspeed))
+            {
+                if (World::GetMvAnticheatDebug())
+                {
+                    sLog.outError("Movement Anticheat: player %s has Gravitation-Hack alarm. anti_jumpbase=%f, anti_justjumped=%u, JumpHeight=%f, last_vspeed=%f",
+                        plMover->GetName(), plMover->m_anti_jumpbase, plMover->m_anti_justjumped, JumpHeight, plMover->m_anti_last_vspeed);
+                }
+                plMover->m_anti_lastcheat = "GraviJump Hack";
+                acpassed = false;
+            }
+
+            // Anti-Jump-Hack
+            if (opcode == MSG_MOVE_JUMP 
+                && !plMover->IsInWater())
+            {
+                if (plMover->m_anti_justjumped == 0)
+                {
+                    plMover->m_anti_justjumped += 1;
+                    plMover->m_anti_jumpbase = movementInfo.GetPos()->GetPositionZ();
+                }
+                else
+                {
+                    if (World::GetMvAnticheatDebug())
+                        sLog.outError("Movement Anticheat: player %s has Jump-Hack alarm. anti_justjumped=%u", plMover->GetName(), plMover->m_anti_justjumped);
+
+                    plMover->m_anti_justjumped = 0;
+                    plMover->m_anti_lastcheat = "Jump Hack";
+                    acpassed = false; //don't process new jump packet
+                }
+            }
+            else if (plMover->IsInWater())
+                plMover->m_anti_justjumped = 0;
+
+            // Anti-Speed-Hack
+            // Disabled to revert: if ((real_delta > allowed_delta) && (allowed_delta > 4) && (delta_z < (plMover->m_anti_last_vspeed * time_delta) || delta_z < 1))
+            if ((real_delta > allowed_delta)
+                && (allowed_delta > 4)
+                && (delta_z < 1))
+            {
+                if (World::GetMvAnticheatDebug())
+                    sLog.outError("Movement Anticheat: player %s has Speed-Hack alarm. real_delta=%f, allowed_delta=%f, delta_z=%f, last_vspeed=%f", plMover->GetName(), real_delta, allowed_delta, delta_z, plMover->m_anti_last_vspeed * time_delta);
+
+                plMover->m_anti_lastcheat = "Speed Hack";
+                acpassed = false;
+            }
+
+            // Anti-Teleport-Hack
+            // Disabled to revert: if ((real_delta > allowed_delta) && (real_delta > (time_delta * 100)))
+            if ((real_delta > 4900.0f) 
+                && !(real_delta < allowed_delta))
+            {
+                if (World::GetMvAnticheatDebug())
+                    sLog.outError("Movement Anticheat: player %s has Teleport-Hack alarm. real_delta=%f, allowed_delta=%f, min_delta=%f ", plMover->GetName(), real_delta, allowed_delta, time_delta * 100);
+
+                plMover->m_anti_lastcheat = "Teleport Hack";
+                acpassed = false;
+            }
+
+            if (movementInfo.time > plMover->m_anti_lastspeed_changetime)
+            {
+                plMover->m_anti_last_hspeed = current_speed; // store current speed
+                plMover->m_anti_last_vspeed = -3.2f; // original value: -2.3f
+                plMover->m_anti_lastspeed_changetime = 0;
+            }
+
+            // Anti-Wall-Hack
+            // Known issues: jump+up, and walking up with low delta_z (one and only way to make it right is to calculate the delta_z of the terrain)
+            // Disabled to revert: if (!plMover->m_anti_isjumping && (tg_z > 1.6f) && (delta_z < (plMover->m_anti_last_vspeed * time_delta)))
+            if (!plMover->m_anti_isjumping && (tg_z > 1.56f) 
+                && (delta_z < plMover->m_anti_last_vspeed))
+            {
+                if (World::GetMvAnticheatDebug())
+                    sLog.outError("Movement Anticheat: player %s has Wall-Hack alarm. tg_z=%f, delta_z=%f, last_vspeed*time_delta=%f", plMover->GetName(), tg_z, delta_z, plMover->m_anti_last_vspeed * time_delta);
 
-        if (movementInfo.GetPos()->GetPositionZ() < -500.0f)
-            plMover->HandleFallUnderMap();
+                plMover->m_anti_lastcheat = "Wall-climbing Hack";
+                acpassed = false;
+            }
+
+            // Anti-Fly-Hack
+            if (((movementInfo.GetMovementFlags() & (MOVEFLAG_CAN_FLY | MOVEFLAG_FLYING | MOVEFLAG_FLYING2)) != 0) 
+                && !(movementInfo.HasMovementFlag(MOVEFLAG_SWIMMING)) && !(plMover->m_anti_flymounted)
+                && !(plMover->HasAuraType(SPELL_AURA_FLY) || plMover->HasAuraType(SPELL_AURA_MOD_FLIGHT_SPEED_MOUNTED)))
+            {
+                if (World::GetMvAnticheatDebug())
+                {
+                    sLog.outError("Movement Anticheat: player %s has Fly-Hack alarm. {SPELL_AURA_FLY=[%X]} {SPELL_AURA_MOD_FLIGHT_SPEED_MOUNTED=[%X]} {SPELL_AURA_MOD_FLIGHT_SPEED_STACKING=[%X]} {SPELL_AURA_MOD_FLIGHT_SPEED_MOUNTED_STACKING=[%X]} {SPELL_AURA_MOD_FLIGHT_SPEED_MOUNTED_NOT_STACKING=[%X]}",
+                        plMover->GetName(),
+                        plMover->HasAuraType(SPELL_AURA_FLY), plMover->HasAuraType(SPELL_AURA_MOD_FLIGHT_SPEED_MOUNTED),
+                        plMover->HasAuraType(SPELL_AURA_MOD_FLIGHT_SPEED_STACKING), plMover->HasAuraType(SPELL_AURA_MOD_FLIGHT_SPEED_MOUNTED_STACKING),
+                        plMover->HasAuraType(SPELL_AURA_MOD_FLIGHT_SPEED_MOUNTED_NOT_STACKING));
+                }
+                plMover->m_anti_lastcheat = "Fly Hack";
+                acpassed = false;
+            }
+
+            // Anti-Water-Walk-Hack
+            if (movementInfo.HasMovementFlag(MOVEFLAG_WATERWALKING) 
+                && !(plMover->HasAuraType(SPELL_AURA_WATER_WALK) | plMover->HasAuraType(SPELL_AURA_GHOST)))
+            {
+                if (World::GetMvAnticheatDebug())
+                    sLog.outError("Movement Anticheat: player %s has Water-Walk-Hack alarm. MovementFlags=[%X], SPELL_AURA_WATER_WALK=[%X]", plMover->GetName(), movementInfo.GetMovementFlags(), plMover->HasAuraType(SPELL_AURA_WATER_WALK));
+
+                plMover->m_anti_lastcheat = "Water Walk Hack";
+                acpassed = false;
+            }
+
+            // Anti-Feather-Fall-Hack
+            if (movementInfo.HasMovementFlag(MOVEFLAG_SAFE_FALL) 
+                && !(plMover->HasAuraType(SPELL_AURA_FEATHER_FALL)))
+            {
+                if (World::GetMvAnticheatDebug())
+                    sLog.outError("Movement Anticheat: player %s has Feather-Fall-Hack alarm. MovementFlags=[%X], SPELL_AURA_FEATHER_FALL=[%X]", plMover->GetName(), movementInfo.GetMovementFlags(), plMover->HasAuraType(SPELL_AURA_FEATHER_FALL));
+
+                plMover->m_anti_lastcheat = "Feather Fall Hack";
+                acpassed = false;
+            }
+
+            // Anti-Teleport-To-Plane-Hack
+            if (movementInfo.GetPos()->GetPositionZ() < 0.0001f 
+                && movementInfo.GetPos()->GetPositionZ() > -0.0001f 
+                && ((movementInfo.GetMovementFlags() & (MOVEFLAG_SWIMMING | MOVEFLAG_CAN_FLY | MOVEFLAG_FLYING | MOVEFLAG_FLYING2)) == 0))
+            {
+                // Prevent using TeleportToPlane.
+                Map *map = plMover->GetMap();
+                if (map)
+                {
+                    float plane_z = map->GetHeight(movementInfo.GetPos()->GetPositionX(), movementInfo.GetPos()->GetPositionY(), MAX_HEIGHT) - movementInfo.GetPos()->GetPositionZ();
+                    plane_z = (plane_z < -500.0f) ? 0 : plane_z; // check holes in height map
+                    if (plane_z > 0.1f || plane_z < -0.1f)
+                    {
+                        if (World::GetMvAnticheatDebug())
+                            sLog.outError("Movement Anticheat: player %s has Teleport-To-Plane-Hack alarm. plane_z: %f ", plMover->GetName(), plane_z);
+
+                        plMover->m_anti_lastcheat = "Teleport To Plane Hack";
+                        acpassed = false;
+                    }
+                }
+            }
+        }
+        else if (movementInfo.HasMovementFlag(MOVEFLAG_ONTRANSPORT) && !plMover->m_anti_plskipanticheat)
+        {
+            // Anti-Wrap
+            if (plMover->m_transport)
+            {
+                float trans_rad = movementInfo.GetTransportPos()->GetPositionX() * movementInfo.GetTransportPos()->GetPositionX() + movementInfo.GetTransportPos()->GetPositionY() * movementInfo.GetTransportPos()->GetPositionY() + movementInfo.GetTransportPos()->GetPositionZ() * movementInfo.GetTransportPos()->GetPositionZ();
+                if (trans_rad > 3600.0f)
+                    acpassed = false;
+            }
+            else
+            {
+                if (GameObjectData const* go_data = objmgr.GetGOData(plMover->m_anti_transportGUID))
+                {
+                    if (World::GetMvAnticheatDebug())
+                        sLog.outBasic("Movement Anticheat: player %s on some transport. xyz: %f, %f, %f", plMover->GetName(), go_data->posX, go_data->posY, go_data->posZ);
+
+                    int mapid = go_data->mapid;
+                    if (plMover->GetMapId() != mapid)
+                    {
+                        acpassed = false;
+                    }
+                    else if (mapid != 369)
+                    {
+                        float delta_gox = go_data->posX - movementInfo.GetPos()->GetPositionX();
+                        float delta_goy = go_data->posY - movementInfo.GetPos()->GetPositionY();
+                        float delta_go = delta_gox*delta_gox + delta_goy*delta_goy;
+                        if (delta_go > 3600.0f)
+                            acpassed = false;
+                    }
+                }
+                else
+                {
+                    if (World::GetMvAnticheatDebug())
+                        sLog.outError("Movement Anticheat: player %s on undefined transport.", plMover->GetName());
+
+                    acpassed = false;
+                }
+            }
+
+            if (!acpassed)
+            {
+                plMover->m_anti_lastcheat = "Transport";
+                if (plMover->m_transport)
+                {
+                    plMover->m_transport->RemovePassenger(plMover);
+                    plMover->m_transport = NULL;
+                }
+                movementInfo.ClearTransportData();
+                plMover->m_anti_transportGUID = 0;
+            }
+        }
+
+        // reset plskipanticheat
+        plMover->m_anti_plskipanticheat = false;
+
+        /* process position-change */
+        if (acpassed)
+        {
+            recv_data.put<uint32>(5, getMSTime());                  // offset flags(4) + unk(1)
+            WorldPacket data(opcode, mover->GetPackGUID().size() + recv_data.size());
+            data << mover->GetPackGUID();
+            data.append(recv_data.contents(), recv_data.size());
+            mover->SendMessageToSet(&data, false);
+
+            if (updateorientationonly)
+                plMover->SetPosition(plMover->GetPositionX(), plMover->GetPositionY(), plMover->GetPositionZ(), movementInfo.GetPos()->GetOrientation());
+            else
+                plMover->SetPosition(movementInfo.GetPos()->GetPositionX(), movementInfo.GetPos()->GetPositionY(), movementInfo.GetPos()->GetPositionZ(), movementInfo.GetPos()->GetOrientation());
+
+            plMover->m_movementInfo = movementInfo;
+
+            if (opcode == MSG_MOVE_FALL_LAND || plMover->m_lastFallTime > movementInfo.GetFallTime() || plMover->m_lastFallZ < movementInfo.GetPos()->GetPositionZ())
+                plMover->SetFallInformation(movementInfo.GetFallTime(), movementInfo.GetPos()->GetPositionZ());
+
+            // we should add the check only for class hunter
+            if (plMover->isMovingOrTurning())
+                plMover->RemoveSpellsCausingAura(SPELL_AURA_FEIGN_DEATH);
+
+            if (movementInfo.GetPos()->GetPositionZ() < -500.0f)
+                plMover->HandleFallUnderMap();
+        }
+        else
+        {
+            WorldPacket data;
+            plMover->SetUnitMovementFlags(MOVEFLAG_NONE);
+            plMover->BuildTeleportAckMsg(&data, plMover->GetPositionX(), plMover->GetPositionY(), plMover->GetPositionZ(), plMover->GetOrientation());
+            plMover->GetSession()->SendPacket(&data);
+            plMover->BuildHeartBeatMsg(&data);
+            plMover->SendMessageToSet(&data, true);
+
+            if (!plMover->isInCombat())
+                plMover->m_anti_alarmcount++;
+
+            if (plMover->m_anti_alarmcount >= World::GetMvAnticheatAlarm())
+            {
+                plMover->m_anti_alarmcount = 0;
+                switch (World::GetMvAnticheatAction())
+                {
+                case 0:
+                    sWorld.SendGMText(LANG_GM_AC_ANNOUNCE, plMover->GetName(), "detected", plMover->m_anti_lastcheat.c_str());
+                    break;
+                case 1:
+                    plMover->GetSession()->KickPlayer();
+                    sWorld.SendGMText(LANG_GM_AC_ANNOUNCE, plMover->GetName(), "kicked", plMover->m_anti_lastcheat.c_str());
+                    break;
+                case 2:
+                    std::string accountName;
+                    AccountMgr::GetName(plMover->GetSession()->GetAccountId(), accountName);
+                    std::stringstream duration;
+                    duration << World::GetMvAnticheatBanDuration() << "s";
+                    sWorld.BanAccount(BAN_ACCOUNT, accountName, duration.str(), plMover->m_anti_lastcheat.c_str(),"AC");
+                    sWorld.SendGMText(LANG_GM_AC_ANNOUNCE, plMover->GetName(), "banned", plMover->m_anti_lastcheat.c_str());
+                    break;
+                }
+            }
+        }
     }
+    else
+    if (getMSTimeDiff(timediff, getMSTime()) > 20)
+        sLog.outError("Anticheat Process Time: %ums : %s [%x]", getMSTimeDiff(timediff, getMSTime()), LookupOpcodeName(opcode), movementInfo.GetMovementFlags());
 }
 
 void WorldSession::HandleForceSpeedChangeAck(WorldPacket& recv_data)
@@ -355,6 +750,11 @@ void WorldSession::HandleForceSpeedChangeAck(WorldPacket& recv_data)
     // Save movement flags
     GetPlayer()->SetUnitMovementFlags(movementInfo.GetMovementFlags());
 
+    // Movement Anticheat
+    GetPlayer()->m_anti_plskipanticheat = true;
+    if (World::GetMvAnticheatDebug())
+        sLog.outBasic("Movement Anticheat: player %s HandleForceSpeedChangeAck tm:%d | %f, %f, %fo(%f) [%X]", GetPlayer()->GetName(), movementInfo.time, movementInfo.GetPos()->GetPositionX(), movementInfo.GetPos()->GetPositionY(), movementInfo.GetPos()->GetPositionZ(), movementInfo.GetPos()->GetOrientation(), movementInfo.GetMovementFlags());
+
     // client ACK send one packet for mounted/run case and need skip all except last from its
     // in other cases anti-cheat check can be fail in false case
     UnitMoveType move_type;
@@ -453,6 +853,11 @@ void WorldSession::HandleMoveKnockBackAck(WorldPacket& recv_data)
 
     // Save movement flags
     GetPlayer()->SetUnitMovementFlags(movementInfo.GetMovementFlags());
+
+    // Movement Anticheat
+    GetPlayer()->m_anti_plskipanticheat = true;
+    if (World::GetMvAnticheatDebug())
+        sLog.outBasic("Movement Anticheat: player %s HandleMoveKnockBackAck tm:%d | %f, %f, %fo(%f) [%X]", GetPlayer()->GetName(), movementInfo.time, movementInfo.GetPos()->GetPositionX(), movementInfo.GetPos()->GetPositionY(), movementInfo.GetPos()->GetPositionZ(), movementInfo.GetPos()->GetOrientation(), movementInfo.GetMovementFlags());
 }
 
 void WorldSession::HandleMoveSetCanFlyAckOpcode(WorldPacket& recv_data)
@@ -469,6 +874,18 @@ void WorldSession::HandleMoveSetCanFlyAckOpcode(WorldPacket& recv_data)
     recv_data.read_skip<uint32>();                          // unk2
 
     GetPlayer()->SetUnitMovementFlags(movementInfo.GetMovementFlags());
+
+    // Movement Anticheat
+    if (movementInfo.HasMovementFlag(MOVEFLAG_FLYING))
+        GetPlayer()->m_anti_flymounted = true;
+    else
+    {
+        GetPlayer()->m_anti_flymounted = false;
+        GetPlayer()->m_anti_plskipanticheat = true;
+    }
+
+    if (World::GetMvAnticheatDebug())
+        sLog.outBasic("Movement Anticheat: player %s HandleMoveSetCanFlyAckOpcode flymounted:%d", GetPlayer()->GetName(), GetPlayer()->m_anti_flymounted);
 }
 
 void WorldSession::HandleMoveHoverAck(WorldPacket& recv_data)
diff --git a/src/game/Player.cpp b/src/game/Player.cpp
index e664071..01d15f7 100644
--- a/src/game/Player.cpp
+++ b/src/game/Player.cpp
@@ -370,6 +370,24 @@ Player::Player (WorldSession *session): Unit()
     rest_type=REST_TYPE_NO;
     ////////////////////Rest System/////////////////////
 
+    // Movement Anticheat
+    m_anti_lastmovetime = 0;          // last movement time
+    m_anti_transportGUID = 0;         // current transport GUID
+    m_anti_last_hspeed = 7.0f;        // horizontal speed, default RUN speed
+    m_anti_lastspeed_changetime = 0;  // last speed change time
+    m_anti_last_vspeed = -2.3f;       // vertical speed, default max jump height
+    m_anti_beginfalltime = 0;         // alternative falling begin time
+    m_anti_plskipanticheat = false;   // seted when player skipanticheat
+    m_anti_flymounted = false;        // seted when player is mounted on flymount
+    m_anti_ontaxipath = false;        // seted when player is on a taxi path
+    m_anti_isjumping = false;         // seted when player is in jump phase
+    m_anti_justjumped = 0;            // jump already began, anti-air jump check
+    m_anti_alarmcount = 0;            // alarm counter
+    m_anti_lastcheat.empty();         // stores last cheat as string
+    m_anti_jumpbase = 0;              // Anti-Gravitation
+
+    /////////////////////////////////
+
     m_mailsLoaded = false;
     m_mailsUpdated = false;
     unReadMails = 0;
@@ -20495,12 +20513,16 @@ bool ItemPosCount::isContainedIn(ItemPosCountVec const& vec) const
 
 void Player::HandleFallDamage(MovementInfo& movementInfo)
 {
-    if (movementInfo.GetFallTime() < 1500)
+    // Removed for Anticheat Fall DMG
+    if (!World::GetEnableMvAnticheat() && movementInfo.GetFallTime() < 1500)
         return;
+    else
+        if (movementInfo.GetFallTime() > 400 && movementInfo.GetFallTime() < 1500) // lower falltime then 400 = cheat
+            return;
 
     // calculate total z distance of the fall
     float z_diff = m_lastFallZ - movementInfo.GetPos()->GetPositionZ();
-    DEBUG_LOG("zDiff = %f", z_diff);
+    DEBUG_LOG("zDiff=%f, FallTime=%u", z_diff, movementInfo.GetFallTime());
 
     //Players with low fall distance, Feather Fall or physical immunity (charges used) are ignored
     // 14.57 can be calculated by resolving damageperc formular below to 0
diff --git a/src/game/Player.h b/src/game/Player.h
index cb35745..b678451 100644
--- a/src/game/Player.h
+++ b/src/game/Player.h
@@ -2296,6 +2296,22 @@ class Player : public Unit, public GridObject<Player>
         RestType rest_type;
         ////////////////////Rest System/////////////////////
 
+        // Movement Anticheat
+        uint32 m_anti_lastmovetime;          // last movement time
+        uint64 m_anti_transportGUID;         // current transport GUID
+        float  m_anti_last_hspeed;           // horizontal speed, default RUN speed
+        uint32 m_anti_lastspeed_changetime;  // last speed change time
+        float  m_anti_last_vspeed;           // vertical speed, default max jump height
+        uint32 m_anti_beginfalltime;         // alternative falling begin time
+        bool m_anti_plskipanticheat;         // seted when player skipanticheat
+        bool m_anti_flymounted;              // seted when player is mounted on flymount
+        bool m_anti_ontaxipath;              // seted when player is on a taxi path
+        bool m_anti_isjumping;               // seted when player is in jump phase
+        uint8 m_anti_justjumped;             // jump already began, anti-air jump check
+        uint8 m_anti_alarmcount;             // alarm counter
+        std::string m_anti_lastcheat;        // stores last cheat as string
+        float m_anti_jumpbase;               // Anti-Gravitation
+
         // Transports
         Transport * m_transport;
 
diff --git a/src/game/TaxiHandler.cpp b/src/game/TaxiHandler.cpp
index eb48863..db078d6 100644
--- a/src/game/TaxiHandler.cpp
+++ b/src/game/TaxiHandler.cpp
@@ -105,6 +105,11 @@ void WorldSession::SendDoFlight(uint16 MountId, uint32 path, uint32 pathNode)
     if (GetPlayer()->hasUnitState(UNIT_STAT_DIED))
         GetPlayer()->RemoveSpellsCausingAura(SPELL_AURA_FEIGN_DEATH);
 
+    // Movement Anticheat
+    GetPlayer()->m_anti_ontaxipath = true;
+    if (World::GetMvAnticheatDebug())
+        sLog.outBasic("Movement Anticheat: player %s SendDoFlight", GetPlayer()->GetName());
+
     while (GetPlayer()->GetMotionMaster()->GetCurrentMovementGeneratorType() == FLIGHT_MOTION_TYPE)
         GetPlayer()->GetMotionMaster()->MovementExpired(false);
 
@@ -193,7 +198,17 @@ void WorldSession::HandleTaxiNextDestinationOpcode(WorldPacket& recv_data)
 
     uint32 curDest = GetPlayer()->m_taxi.GetTaxiDestination();
     if (!curDest)
+    {
+        // Movement Anticheat
+        GetPlayer()->Relocate(movementInfo.GetPos());
+        GetPlayer()->m_movementInfo = movementInfo;
+        GetPlayer()->m_anti_lastmovetime = movementInfo.time;
+        GetPlayer()->m_anti_plskipanticheat = true;
+        if (World::GetMvAnticheatDebug())
+            sLog.outBasic("Movement Anticheat: player %s HandleTaxiNextDestinationOpcode", GetPlayer()->GetName());
+        // Movement Anticheat
         return;
+    }
 
     TaxiNodesEntry const* curDestNode = sTaxiNodesStore.LookupEntry(curDest);
 
@@ -206,6 +221,12 @@ void WorldSession::HandleTaxiNextDestinationOpcode(WorldPacket& recv_data)
             GetPlayer()->GetMotionMaster()->MovementExpired(false);
     }
 
+    // Movement Anticheat
+    GetPlayer()->SetPosition(movementInfo.GetPos()->GetPositionX(), movementInfo.GetPos()->GetPositionY(), movementInfo.GetPos()->GetPositionZ(), movementInfo.GetPos()->GetOrientation());
+    GetPlayer()->m_movementInfo = movementInfo;
+    GetPlayer()->m_anti_lastmovetime = movementInfo.time;
+    // Movement Anticheat
+
     // far teleport case
     if (curDestNode && curDestNode->map_id != GetPlayer()->GetMapId())
     {
diff --git a/src/game/World.cpp b/src/game/World.cpp
index 80175c4..edfb42a 100644
--- a/src/game/World.cpp
+++ b/src/game/World.cpp
@@ -69,6 +69,14 @@ int32 World::m_visibility_notify_periodOnContinents = DEFAULT_VISIBILITY_NOTIFY_
 int32 World::m_visibility_notify_periodInInstances  = DEFAULT_VISIBILITY_NOTIFY_PERIOD;
 int32 World::m_visibility_notify_periodInBGArenas   = DEFAULT_VISIBILITY_NOTIFY_PERIOD;
 
+// Movement Anticheat
+bool World::m_EnableMvAnticheat = true;
+bool World::m_MvAnticheatDebug = false;
+uint8 World::m_MvAnticheatGmLevel = 0;
+uint8 World::m_MvAnticheatAction = 0;
+uint8 World::m_MvAnticheatAlarm = 1;
+uint32 World::m_MvAnticheatBanDuration = 86400;
+
 // World constructor
 World::World()
 {
@@ -521,6 +529,14 @@ void World::LoadConfigSettings(bool reload)
         rate_values[RATE_DURABILITY_LOSS_BLOCK] = 0.0f;
     }
 
+    // Movement Anticheat
+    m_EnableMvAnticheat = sConfig.GetBoolDefault("Anticheat.Movement.Enable", true);
+    m_MvAnticheatDebug = sConfig.GetBoolDefault("Anticheat.Movement.Debug", false);
+    m_MvAnticheatGmLevel = sConfig.GetIntDefault("Anticheat.Movement.GmLevel", 0);
+    m_MvAnticheatAction = sConfig.GetIntDefault("Anticheat.Movement.Action", 0);
+    m_MvAnticheatAlarm = sConfig.GetIntDefault("Anticheat.Movement.Alarm", 1);
+    m_MvAnticheatBanDuration = sConfig.GetIntDefault("Anticheat.Movement.BanDuration", 86400);
+
     // Read other configuration items from the config file
 
     m_configs[CONFIG_COMPRESSION] = sConfig.GetIntDefault("Compression", 1);
diff --git a/src/game/World.h b/src/game/World.h
index fc70e52..e6f35b5 100644
--- a/src/game/World.h
+++ b/src/game/World.h
@@ -565,6 +565,14 @@ class World
         static int32 GetVisibilityNotifyPeriodInInstances() { return m_visibility_notify_periodInInstances;  }
         static int32 GetVisibilityNotifyPeriodInBGArenas()  { return m_visibility_notify_periodInBGArenas;   }
 
+        // Movement Anticheat
+        static bool GetEnableMvAnticheat()              { return m_EnableMvAnticheat;       }
+        static bool GetMvAnticheatDebug()               { return m_MvAnticheatDebug ;       }
+        static uint8 GetMvAnticheatGmLevel()            { return m_MvAnticheatGmLevel;      }
+        static uint8 GetMvAnticheatAction()             { return m_MvAnticheatAction;       }
+        static uint8 GetMvAnticheatAlarm()              { return m_MvAnticheatAlarm;        }
+        static uint32 GetMvAnticheatBanDuration()       { return m_MvAnticheatBanDuration;  }
+
         void ProcessCliCommands();
         void QueueCliCommand(CliCommandHolder* commandHolder) { cliCmdQueue.add(commandHolder); }
 
@@ -652,6 +660,14 @@ class World
         static int32 m_visibility_notify_periodInInstances;
         static int32 m_visibility_notify_periodInBGArenas;
 
+        // Movement Anticheat
+        static bool m_EnableMvAnticheat;
+        static bool m_MvAnticheatDebug;
+        static uint8 m_MvAnticheatGmLevel;
+        static uint8 m_MvAnticheatAction;
+        static uint8 m_MvAnticheatAlarm;
+        static uint32 m_MvAnticheatBanDuration;
+
         // CLI command holder to be thread safe
         ACE_Based::LockedQueue<CliCommandHolder*, ACE_Thread_Mutex> cliCmdQueue;
         SqlResultQueue *m_resultQueue;
diff --git a/src/worldserver/worldserver.conf.dist b/src/worldserver/worldserver.conf.dist
index 48bb574..6f89e79 100644
--- a/src/worldserver/worldserver.conf.dist
+++ b/src/worldserver/worldserver.conf.dist
@@ -2057,3 +2057,43 @@ Die.Command.Mode = 1
 AutoBroadcast.On = 0
 AutoBroadcast.Center = 0
 AutoBroadcast.Timer = 60000
+
+###############################################################################
+# MOVEMENT ANTICHEAT
+#
+#    Anticheat.Movement.Enable
+#        Enable Movement Anticheat
+#        Default: 1 - (Enabled)
+#                 0 - (Disabled)
+#
+#    Anticheat.Movement.Debug
+#        Debug messages in console
+#        Default: 0 - (Disabled)
+#                 1 - (Enabled)
+#
+#    Anticheat.Movement.GmLevel
+#        Detection occurs below and at the same GmLevel
+#        Default: 0 - (Only Players)
+#
+#    Anticheat.Movement.Action
+#        Action on failed check
+#        Default: 0 (SendGMsMessage)
+#                 1 (Kick)
+#                 2 (Ban)
+#
+#    Anticheat.Movement.Alarm
+#        When the action should occur
+#        Default: 1 (Alarm)
+#
+#    Anticheat.Movement.BanDuration
+#        Time (in seconds) an account will be banned.
+#        Default: 86400 - (24 hours)
+#
+###############################################################################
+
+Anticheat.Movement.Enable = 1
+Anticheat.Movement.Debug = 0
+Anticheat.Movement.GmLevel = 0
+Anticheat.Movement.Action = 0
+Anticheat.Movement.Alarm = 1
+Anticheat.Movement.BanDuration = 86400
